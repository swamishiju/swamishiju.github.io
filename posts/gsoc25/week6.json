{"content": "\n## Weekly Agenda\n\nThis week was focused on Union type features. \nFirst was to implement the access syntax for Union types\nand to do a refactor of the ASR structure of Union types.\n\nThe access was quick to implement. However, the ASR refactor\nencountered a major blocker: it depends on the StructType \nrefactor PR. As of the time of this report, the Union type\nPR remains in draft status.\n\n## Achievements\n\n- Implemented Union type access\n- Union ASR type refactor\n\n## Code Samples\n\n```f90\nprogram lp_test\n    type:: test_type\n        integer :: x\n        real    :: y\n    end type\n\n    type(test_type)  :: test_union\n\n    ! Memory value of pi\n    test_union%x = 1078530011 \n\n    ! Doesn't currently support direct operations\n    x = test_union%y\n    if ( abs(x - 3.141593) > eps ) error stop\n\nend program\n```\n            \n## Pull Requests\n\n- [#7935 Union access implemented](https://github.com/lfortran/lfortran/pull/7935)\n- [#7966 Union ASR Refactor](https://github.com/lfortran/lfortran/pull/7966)\n\n## Goals for next week\n\nThe main goal for next week is get accessing Union elements \nso we robustly test if the memory allocation is proper and\nsupporting pythonic types inside union.\n\nOther goals include things like fixing failing tests in \nLPython after sync and trying to completely remove the \nreliance on typecodes.\n"}