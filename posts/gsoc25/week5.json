{"content": "\n## Weekly Agenda\n\nThis week was spent refactoring the old backend for the\npython types to have less reliance on functionality that \nwe plan to phase out like the type_code design and the\ncreate_gep function. This would make the backend more robust\nand support the new type changes being worked on for LFortran.\n\nI also parallelly started work on Union types as part of my \noriginal proposal.\n\n## Achievements\n\n- Some misc fixes in tuple backend\n- Fixed support string type keys for dicts\n- Heavily optimized list pop\n- Exposed union type to LFortran frontend\n- Refactored backed for less reliance on create_gep, typecode\n- Successfully merged a month long sync PR for LPython\n\n## Code Samples\n\n```f90\nprogram lp_test\n\n    integer :: x\n    _lfortran_tuple(integer, integer)                                                :: t1\n    _lfortran_tuple(integer, integer)                                                :: t2\n    _lfortran_tuple(_lfortran_tuple(integer, integer),_lfortran_tuple(integer, integer), &\n      _lfortran_tuple(integer, integer),_lfortran_tuple(integer, integer))           :: t3\n\n    _lfortran_dict(_lfortran_tuple(integer, integer), _lfortran_tuple(real, real))   :: d1\n\n    t1 = _lfortran_tuple_constant(-1, -2)\n    t2 = _lfortran_tuple_constant(-3, -4)\n    t3 = _lfortran_tuple_constant(t1, t2, t1, t2)\n\n    if ( .not. _lfortran_eq(_lfortran_get_item(t3, 0), t1) ) error stop\n\n\n    type:: test_type\n        integer :: x\n        real    :: y\n    end type\n\n    _lfortran_union_type :: test_type1 \n        integer :: x\n        real    :: i\n        type(test_type) :: y\n    end _lfortran_union_type\n\n\n    _lfortran_union_type :: test_type2 \n        integer :: x\n        real    :: i\n        type(test_type) :: y\n    end _lfortran_union_type\n\n\n    type(test_type) :: t_ty\n    type(test_type1) :: t_ty1\n    type(test_type2) :: t_ty2\n\nend program\n```\n            \n\n## Optimization Benchmark\n\nTest Code\n```f90\nprogram test\n    implicit none\n    _lfortran_list(integer):: x\n    integer:: i, g\n        do i = 1, 100000\n    call _lfortran_list_append(x, i)\n    end do\n\n    do i = 1, 100000\n        g = _lfortran_pop(x, 0)\n    end do\nend program test\n```\n \n```sh\n#! bin/bash\n# Pre-optimization\n\ntime lfortran test.f90\n# 17.23s\ntime lfortran test.f90 --fast\n# 0.91s\n\n\n# Post-optimization\n\ntime lfortran test.f90\n# 0.93s\ntime lfortran test.f90 --fast\n# 0.92s\n```\n\n## Pull Requests\n\n- [#7873 Misc fixes for tuple types](https://github.com/lfortran/lfortran/pull/7873)\n- [#7896 Implemented support for string key in dict type](https://github.com/lfortran/lfortran/pull/7896)\n- [#7898 Optimized list pop](https://github.com/lfortran/lfortran/pull/7898)\n- [#7901 Refactored backend for less reliance on typecodes](https://github.com/lfortran/lfortran/pull/7901)\n- [#7909 Exposed the Union type to LFortran](https://github.com/lfortran/lfortran/pull/7909)\n- [#7912 Refactored backend for less reliance on create_gep](https://github.com/lfortran/lfortran/pull/7912)\n- [#2840 Syncing LPython to latest libasr](https://github.com/lcompilers/lpython/pull/2840)\n\n## Goals for next week\n\nThe main goal for next week is get accessing Union elements \nso we robustly test if the memory allocation is proper and\nsupporting pythonic types inside union.\n\nOther goals include things like fixing failing tests in \nLPython after sync and trying to completely remove the \nreliance on typecodes.\n"}